
<!-- ```{r setup, include=FALSE} -->
<!--  is_pdf_output = function() { -->
<!--   knitr::opts_knit$get("rmarkdown.pandoc.to") =="latex" -->
<!--  } -->
<!-- ``` -->

<!-- ```{r setup2, include=FALSE} -->
<!--  is_html_output = function() { -->
<!--   knitr::opts_knit$get("rmarkdown.pandoc.to") =="html4" -->
<!--  } -->
<!-- size.fig = "100%" -->
<!-- ``` -->

```{r message=FALSE, warning=FALSE, paged.print=FALSE, include=FALSE}
load("~/Google Drive/PhDThesis/RData/Math.RData")
```

# Mathematical foundation of cell-type deconvolution of biological data {#methods}

In this chapter, we will discuss how mathematical models can be used to extract information about specific cell-types from 'bulk' transcriptome data or how to de-mix mixed sources.  It will introduce you to basic concepts of approaches adapted for cell-type deconvolution, show an overview of the evolution of the field  as well as it will explicit most tools for estimating presence and proportion of immune cells within cancer biopsies. 

Deconvolution - definition

Explain the principle 


```{r deconvolution-cartoon, fig.cap='(ref:deconvolution-cartoon-caption)',fig.scap="(ref:deconvolution-cartoon-scaption)", out.width='100%', fig.align='center', echo = FALSE}

if (is_pdf_output()) {
  knitr::include_graphics('figures-ext/deconv.pdf')
} else {
  knitr::include_graphics('figures-ext/deconv.png')
}
```

(ref:deconvolution-cartoon-caption) **Principle of the deconvolution applied to transcriptome** Graphical illustration of the deconvolution of mixed samples. Starting from the left, gene expression of genes A B C is a sum of expression of cell types 1, 2, 3, 4. After deconvolution, cell types are separated and gene expression of each cell type is estimated taking into account cell type proportions.


(ref:deconvolution-cartoon-scaption) **Principle of the deconvolution applied to transcriptome**


## Introduction to supervised  and unsupervised learning

* ML 
* Explaining difference between supervised and unsupervised learning technically and in our context



Unsupervised learning The computer is handed over some data to learn from and is the source for selecting an action, although no feedback is given so the computer has no clue of how well it did. 

Supervised learning The computer is handed over some data to learn from and is also told what is the right decision in each case. This requires a lot of observing. 

Reinforcement learning The computer is handed over some data to learn from and receives feedback on how well it did based on the result, but is not told which specific action was good or bad. 

Clustering

## Cell-type deconvolution models of bulk transcriptome
### Literature overview

```{r x2, results="asis", echo = FALSE}
if(is_html_output()){cat("<table>",paste0("<caption>", "(#tab:mytab)","<b>", "Summary of methods for cell-type deconvolution of bulk transcriptome","</b>", "</caption>"),"</table>", sep ="\n")}
```
```{r x, echo=FALSE}
if(is_html_output()){
 #devtools::install_github('rstudio/DT')
library(DT)
library(readxl)
# decon_meth <- read_excel("RData/decon_meth.xlsx")
# decon_meth$data <- as.factor(decon_meth$data)
# decon_meth$type <- as.factor(decon_meth$type)
# decon_meth$proportions.in <- as.factor(decon_meth$proportions.in)
# decon_meth$profiles.in <- as.factor(decon_meth$profiles.in)
# decon_meth$application <- as.factor(decon_meth$application)
# decon_meth$out.profiles <- as.factor(decon_meth$out.profiles)
# decon_meth$out.proportions <- as.factor(decon_meth$out.proportions)
# decon_meth$category <- as.factor(decon_meth$category)
# decon_meth$language <- as.factor(decon_meth$language)
# decon_meth$published <- as.factor(decon_meth$published)
# decon_meth$previously.covered <- as.factor(decon_meth$previously.covered)
# decon_meth[!(decon_meth$availability  %in% "NA"| decon_meth$availability  %in% "broken link"),]$availability <-  paste0("<a href=\"", decon_meth[!(decon_meth$availability  %in% "NA"| decon_meth$availability  %in% "broken link"),]$availability,"\">",decon_meth[!(decon_meth$availability  %in% "NA"| decon_meth$availability  %in% "broken link"),]$availability,"</a>")
# decon_meth$doi <- paste0("<a href=\"", decon_meth$doi,"\">",decon_meth$doi,"</a>")
# mytab <- datatable(decon_meth, filter = 'top', options = list(
#   columnDefs = list(list(width = '10em', targets = list(1,2,14)), list(width="30em", targets=list(4)),list(width='5em', targets= list(5, 7, 8, 9))),
#   pageLength = 20,
#   autoWidth = TRUE,
#   scrollX=TRUE),
#   rownames = FALSE,
# width = '100%',
# caption = NULL,
# escape = FALSE
# )
mytab
}
```

```{r mytab, echo = FALSE }
if(!is_html_output()){
  library(kableExtra)
  library(readxl)
decon_meth <- read_excel("RData/decon_meth.xlsx")
decon_meth$data <- as.factor(decon_meth$data)
decon_meth$type <- as.factor(decon_meth$type)
decon_meth$proportions.in <- as.factor(decon_meth$proportions.in)
decon_meth$profiles.in <- as.factor(decon_meth$profiles.in)
decon_meth$application <- as.factor(decon_meth$application)
decon_meth$out.profiles <- as.factor(decon_meth$out.profiles)
decon_meth$out.proportions <- as.factor(decon_meth$out.proportions)
decon_meth$category <- as.factor(decon_meth$category)
decon_meth$language <- as.factor(decon_meth$language)
decon_meth$published <- as.factor(decon_meth$published)
decon_meth$previously.covered <- as.factor(decon_meth$previously.covered)
#decon_meth[!(decon_meth$availibility  %in% "NA"| decon_meth$availibility  %in% "broken link"),]$availibility <-  paste0("<a href=\"", decon_meth[!(decon_meth$availibility  %in% "NA"| decon_meth$availibility  %in% "broken link"),]$availibility,"\">",decon_meth[!(decon_meth$availibility  %in% "NA"| decon_meth$availibility  %in% "broken link"),]$availibility,"</a>")
#decon_meth$doi <- paste0("<a href=\"", decon_meth$doi,"\">",decon_meth$doi,"</a>")
tab.sel <- data.frame(decon_meth[,c("name","data", "type", "doi", "year", "application", "availability", "out.profiles", "out.proportions", "category", "language", "citations", "pop.index", "previously.covered" )])
tab.sel.o <- tab.sel[order(-tab.sel$year),]
tab.sel.o$pop.index <- round(tab.sel.o$pop.index,2)
  kable(tab.sel.o, format="latex",row.names = FALSE, align = 'c', booktabs = T , caption='(ref:mytab-caption)', escape =TRUE, caption.short = "Summary of methods for cell-type deconvolution of bulk transcriptome") %>%
     kable_styling(latex_options= c("striped", "scale_down"), full_width =F )  %>% landscape()
  # %>%
  # column_spec(1:4, width = "9em", border_left = T) %>%
  #  column_spec(4, width = "9em",  border_left = T, border_right = T)

}

  
```

   
(ref:mytab-caption) **Summary of methods for cell-type deconvolution of bulk transcriptome**. Data gathered based on pubmed and google scholar search in May 2018.


Tab. \@ref(tab:mytab)


```{r plotsetup, echo = FALSE, warning=FALSE, include=FALSE}
library(ggplot2)
library(plotly)
library(readxl)
decon_meth <- read_excel("RData/decon_meth.xlsx")
tab.sel <- data.frame(decon_meth[,c("name","data", "type", "doi", "year", "application", "availability", "out.profiles", "out.proportions", "category", "language", "citations", "pop.index", "previously.covered" )])
tab.sel.o <- tab.sel[order(-tab.sel$year),]

pap.year <- data.frame(table(tab.sel.o$year))
colnames(pap.year) <- c("year", "nb. of papers")

# p <-
#   ggplot(data = pap.year, aes(x = year, y = `nb. of papers`, group = 1)) +
#   geom_line() +
#   geom_point() + theme_bw() 
p <- ggplot(data = pap.year, aes(x = year, y = `nb. of papers`, width=0.5)) +
  geom_bar(stat = "identity", colour= "black", fill="grey") +
  theme_bw()+
 annotate(
    "text",
    x = 13,
    y = 4.3,
    label = "CIBERSORT",
    colour = "red"
  ) + annotate(
    "text",
    x = 11,
    y = 11.6,
    label = "ESTIMATE\n CellMix toolbox",
    colour = "red"
  ) + annotate(
    "text",
    x = 14,
    y = 7.3,
    label = "MCPcounter",
    colour = "red"
  ) + annotate(
    "text",
    x = 15,
    y = 12.6,
    label = "xCell\n EPIC",
    colour = "red"
  ) + annotate(
    "text",
    x = 7,
    y = 2.3,
    label = "Abbas et al.",
    colour = "red"
  ) + annotate(
    "text",
    x = 8,
    y = 4.3,
    label = "csSAM",
    colour = "red"
  )

```


```{r pubyear, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE, fig.cap='(ref:pubyear-caption)', out.width='70%', fig.align='center', out.width=size.fig}

if (is_pdf_output()) {
  p
} else {
  ggplotly(p, tooltip = c("x", "y"))
}

```


(ref:pubyear-caption) **Distibution of publications of cell-type deconvolution of bulk transcriptome over the years**. In red: hallmark publications. Data gathered based on pubmed and google scholar search in May 2018.

```{r languagesA,  echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE, fig.cap='caption', out.width=size.fig, fig.align='center'}
if(is_html_output()){

  df <-
    data.frame(category = as.character(tab.sel$category),
               value = rep(1, nrow(tab.sel)))
  
  res <- by(df$value, df$category, sum)
  stat.1 <- data.frame(value = do.call(rbind, as.list(res)))
  stat <-
    data.frame(category = row.names(stat.1),
               value = do.call(rbind, as.list(res)))
  
  a <-
    plot_ly(
      stat,
      labels = ~ category,
      values = ~ value,
      type = 'pie',
      textposition = 'inside',
      textinfo = 'label+percent',
      insidetextfont = list(color = '#FFFFFF', size = 20),
      marker = list(colors = colors,
                    line = list(color = '#FFFFFF', width = 1))
    ) %>%
    layout(
      title = "a) Percentage of used approach type",
      xaxis = list(
        showgrid = FALSE,
        zeroline = FALSE,
        showticklabels = FALSE
      ),
      yaxis = list(
        showgrid = FALSE,
        zeroline = FALSE,
        showticklabels = FALSE
      )
    )
  a
} 
```

```{r languagesB,  echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE, fig.cap='caption', out.width=size.fig, fig.align='center'}
if(is_html_output()){
  df <-
    data.frame(type = as.character(tab.sel$type), value = rep(1, nrow(tab.sel)))
  
  res <- by(df$value, df$type, sum)
  stat.1 <- data.frame(value = do.call(rbind, as.list(res)))
  stat <-
    data.frame(type = row.names(stat.1), value = do.call(rbind, as.list(res)))
  
  b <-
    plot_ly(
      stat,
      labels = ~ type,
      values = ~ value,
      type = 'pie',
      textposition = 'inside',
      textinfo = 'label+percent',
      insidetextfont = list(color = '#FFFFFF', size = 20),
      marker = list(colors = colors,
                    line = list(color = '#FFFFFF', width = 1))
    ) %>%
    layout(
      title = "b) Percentage of supervised/unsupervised tools",
      xaxis = list(
        showgrid = FALSE,
        zeroline = FALSE,
        showticklabels = FALSE
      ),
      yaxis = list(
        showgrid = FALSE,
        zeroline = FALSE,
        showticklabels = FALSE
      )
    )
  b
  
} 
```

```{r languagesC,  echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE, fig.cap='(ref:languagesABC-caption)', out.width=size.fig, fig.align='center'}
if(is_html_output()){
  tab.sel$language[grep(".*R.*",  tab.sel$language)] <- "R"
df <- data.frame(language = as.character(tab.sel$language), value = rep(1, nrow(tab.sel)))

res <- by(df$value, df$language, sum)
stat.1 <- data.frame( value = do.call(rbind,as.list(res)))
stat <- data.frame(language = row.names(stat.1), value = do.call(rbind,as.list(res)))

c <- plot_ly(stat, labels = ~language, values = ~value, type = 'pie',textposition = 'inside',
        textinfo = 'label+percent',  insidetextfont = list(color = '#FFFFFF', size = 20), marker = list(colors = colors,
                      line = list(color = '#FFFFFF', width = 1))) %>%
  layout(title="c) Percentage of the programming languages of implementation", xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
         yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE))
c

} 
```

```{r caption-html, results="asis", echo= FALSE}
if(is_html_output()){
cat("(ref:languagesABC-caption) **Simple statistics illustrating characteristics of published cell-type deconvolution tools**: **a)** Percentage of used approach type, **b)** Percentage of supervised/ unsupervised tools, **c)** Percentage of the programming languages of implementation. Data gathered based on pubmed and google scholar search in May 2018.")
}
```


```{r languages, fig.cap='(ref:lang-caption)',fig.scap="Simple statistics illustrating characteristics of published cell-type deconvolution tools", out.width='33%', fig.ncol= 3, fig.subcap= c("approach type", "supervised/unsupervised", "programming language"), echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
if(is_pdf_output()) {
knitr::include_graphics(c("./figures-ext/piechartA.png", "./figures-ext/pichartB.png", "./figures-ext/pirChart.png"))
}
```

```{r caption-pdf, results="asis", echo = FALSE}
if(is_pdf_output()){
  cat("(ref:lang-caption) **Simple statistics illustrating characteristics of published cell-type deconvolution tools**: \\@ref(fig:languages1) - Percentage of used approach type, \\@ref(fig:languages2) - Percentage of supervised/unsupervised tools, \\@ref(fig:languages3) - Percentage of the programming languages of implementation. Data gathered based on pubmed and google scholar search in May 2018.")
}
```

<!-- (ref:lang-caption) this is a captions are: \@ref(fig:languages1) some \@ref(fig:languages2) ererer -->



* the table 
* graph : percentage of programming language
* nb pub / year
* top methods (nb of citation based)
* published code

### Regression-based methods

#### basis matrix

* define what basis matrix is vs signatures vs marker genes
* explain the differences between basis matrices in published algorithms

3.4.7 Signature Matrix 

CIBERSORT requires an input matrix of reference gene expression signa- tures called "signature matrix", and this matrix has in earlier studies been called base or basis matrices according to Newman et al.[7]. The signature matrix possesses a small number of "trademark genes" for pure cell lines. Trademark genes are significantly differentially expressed genes among all the cell lines, meaning that genes that express a high score for one cell line, and a low score for the others, are relevant for the signature matrix. The authors stated that while developing their own signature matrix (LM22), expressed genes were found by using a two-sided unequal variance t-text, and genes with a false discovery rate below <0.3 are considered signific- ant[7]. The significant genes were sorted by decreasing fold change com- pared to other cell lines, and top G were kept for signature matrices. After iterating G from 50 to 200, they kept the signature matrix which had the lowest condition number (11.4) where G was 102 and the final signature matrix consisted of 547 distinct genes[7]. 

The number of genes present in signature matrix vary based on a combin- ation of the number of pure cell lines used, and how many genes are re- quired to express a specific pure cell line. Genes from the signature matrix are used for recognizing cell subsets within a mixture. The signature mat- rix is an essential part of CIBERSORT, and is required to run CIBERSORT. Newman et al. (2015) state that using a signature matrix (1) speeds up the run time as it ignores genes which do not express any particular cell sub- set, and (2) achieves a better signal-to-noise ratio as it preselects reference profiles having maximal discriminatory power[7]. They also state that their approach is unique compared to others for developing signature matrices like LLSR[8]. The signature genes are central for SVR when deconvolving a mixture, and the result is an estimated mixture calculated by CIBERSORT. The result from CIBERSORT also provides a Pearson correlation which is calculated by comparing the signature genes from the original mixture to the equivalent genes in the estimated mixture. 

### regression algorithm

* explain what it is for 
* explain how it works
* explain the different approaches



### Enrichment-based methods 

### Probabilistic methods

### Convex-hull based methods

### Matrix factorisation methods



### Others aspects

* explain possible normalisation 

* explain additional possible features 

## Deconvolution of other data types

## Methodological dimension of the thesis

* expose state of art and compare existing tools 
* adjustment of existing methodology
* develop a new user-friendly tool
* discuss limitations of computational approaches in biology
* data integration
* exploration of data




```{r include=FALSE}
#save(mytab , file = "./RData/Math.RData")
```